# -*- coding: utf-8 -*-
"""metric_graphs.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AZlfN-upZGYZofm0OYJdhfhO484DKhr3
"""

!pip install numpy_indexed
import numpy as np
from PIL import Image
import numpy_indexed as npi

from google.colab import drive
drive.mount('/content/drive')
import matplotlib.image as img

a= np.eye(2)
b = 2*np.eye(2)
b[1,1] = 0
c = np.intersect1d(np.where( a ==1 )[0] , np.where( b==1 )[0])
len([])
[(m,n) for m in range(5) for n in range(5) if m != n]

file_name = '/content/drive/My Drive/MSRC_ObjCategImageDatabase_v2/GroundTruth/1_18_s_GT.bmp'

image = img.imread(file_name)

(s0,s1) = (np.shape(image)[0],np.shape(image)[1])
mat = np.zeros((s0,s1))
label = np.unique(image[0],axis = 0)
n = len(np.unique(image[0],axis = 0))

for i in range(s0):
  for j in range(s1):
    for k in range(n):
      if (image[i,j,:] == label[k]).all():
        mat[i,j] = k
        #break



labels = [k for k in range(len(label))]

np.unique(image[0],axis = 0)

A = np.array([[str(image[i,j]) for i in range(image.shape[0])] for j in range(image.shape[1])])
labels = list(np.unique(A))

for k in range(len(labels)):
  A[A == labels[k]] = k

A = A.astype(int)
np.unique(A)

A = [[str(image[i,j]) for i in range(image.shape[0])] for j in range(image.shape[1])]
np.unique(A)

mat[100,200]
label
#GPA(mat,mat,labels)

def N_m_n(context_matrix,ground_truth,m,n):

  index = len(npi.intersection(np.argwhere( context_matrix == n ) , np.argwhere( ground_truth == m )))
  return index

def GPA(context_matrix,ground_truth,labels):
  
  num = np.sum([N_m_n(context_matrix,ground_truth,m,m) for m in labels])
  den = np.sum([N_m_n(context_matrix,ground_truth,m,n) for m in labels for n in labels])
  return num/den

def ACA(context_matrix,ground_truth,labels):

  nb_labels = len(labels)
  num = (1/nb_labels)*np.sum([N_m_n(context_matrix,ground_truth,m,m) for m in labels])
  aca = []
  for m in labels :
    den = np.sum([N_m_n(context_matrix,ground_truth,m,n) for n in labels]) 
    aca.append(num/den)
  return np.mean(aca)

def mIoU(context_matrix,ground_truth,labels):
  nb_labels = len(labels)
  num = (1/nb_labels)*np.sum([N_m_n(context_matrix,ground_truth,m,m) for m in labels])
  mIoU = []
  for m in labels :
    den = np.sum([N_m_n(context_matrix,ground_truth,m,n) + N_m_n(context_matrix,ground_truth,n,m)  for n in labels]) - N_m_n(context_matrix,ground_truth,m,m)
    mIoU.append(num/den)
  return np.mean(mIoU)